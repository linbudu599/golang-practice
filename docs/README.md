# Golang Study

## 特色

- 简洁: 待定, 看学的快乐不
- 并行: 有听闻的重要特色 特别适合高并发场景啥的

## 语法

- 顶部包声明, 必须包含`main`
- 引入包, 如`fmt`实现了格式化IO的工具函数
- PrintIn自动增加换行字符`\n`
- 以大写字符开头的标识符即相当于被导出
- `{` 不能单独放在一行
- 字符串连接同样基于`"+"`

### 数据类型

不带`:`的ts? `var a bool = true`

无(有)符号整型 uint 与 init

float

### 符号变量 & 语言常量

var idet type = val;

不带val则为零值 "" 0 false

也可不带type进行类型推导

省略var 使用:=声明变量 但必须确保新声明了变量 不用带类型
但是只能用在函数体内而不能用于全局变量声明赋值

多变量声明 类似于python

`a, b = b, a` 交换

空白标识符_ `_, b = 5, 7` 5会被抛弃

const常量声明

可用于 枚举 表达式值计算

iota: 可被编译器修改的常量

可理解为const语句块内的行索引值 用于枚举

### 变量作用域

局部-全局-形参

### 指针

使用&去取回变量地址

定义指针变量 - 赋值 - 访问指针变量中的地址

指针数组

指向指针的指针 **

可以使用指针作为函数参数, 毕竟*[指针]就是值

### 语言结构体(接口)

类似于接口

声明实例方式

函数体参数

结构体指针

### 切片

对数组的抽象 因为数组的长度不可改变 但切片的可以 可以追加元素等

就像是动态数组

长度与容量

从数组延申

切片截取

append 与 copy

### map

无序键值对


### 范围

用于迭代

像Object.entries()

返回idx-val/key-val

### 类型转换

不支持隐式转换

### 数据类型接口

### 错误处理

阿哲 果然很诡异

```go
func Sqrt(f float64) (float64, error) {
    if f < 0 {
        return 0, errors.New("math: square root of negative number")
    }
    // 实现
}

result, err:= Sqrt(-1)

if err != nil {
   fmt.Println(err)
}
```

### 并发

使用go关键字开启goroutine(轻量级线程), 调度由golang运行时管理

同一个程序的所有goroutine共享同一个地址空间

通道 用于传递数据的数据结构 用-> <- 指定方向

默认是不带缓冲区的 发送端发送就要有接收端接受

缓冲区允许发送和接收变成异步的 可以等待接收端获取数据

不带缓冲的通道 发送方会阻塞直到接收方接受了值

带了缓冲就可以先将值开被盗缓冲区

如果缓冲区满了就需要等待直到某个接收方获取到值

遍历通道与关闭通道

## 其他

- 格式化: go fmt 